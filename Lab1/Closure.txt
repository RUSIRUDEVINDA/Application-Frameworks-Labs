EXPLANATION: Closure.html
===========================

This code demonstrates JavaScript closures - a function retaining access to its parent function's variables even after the parent function has finished executing.

STEP-BY-STEP BREAKDOWN:
=======================

Step 1: Define the outer function
    function greeting(){
    - This is the parent/outer function that will be called

Step 2: Create a local variable in the outer function
    let message = 'Hi'
    - message is a local variable inside greeting()
    - It only exists within the scope of greeting()
    - Once greeting() finishes, this variable would normally be garbage collected

Step 3: Define an inner function inside the outer function
    function sayHi(){
        console.log(message)
    }
    - sayHi() is defined INSIDE greeting()
    - sayHi() references the variable 'message' from its parent function
    - This creates a closure - sayHi() "closes over" the message variable
    - Even after greeting() returns, sayHi() remembers the message variable

Step 4: Return the inner function from the outer function
    return sayHi
    - greeting() returns the function itself (not calling it)
    - Returns a reference to sayHi function
    - The returned function still has access to the message variable

Step 5: Assign the returned function to a variable
    let hi = greeting()
    - Calls greeting()
    - greeting() runs once and returns the sayHi function
    - hi now holds a reference to the sayHi function
    - Importantly: The message = 'Hi' variable is still in memory because sayHi needs it

Step 6: Call the returned function
    hi() // still can access the message variable
    - Calls the sayHi function stored in variable hi
    - sayHi() still has access to message = 'Hi'
    - console.log(message) executes and logs 'Hi' to console
    - This works even though greeting() has already finished executing

WHY IS THIS IMPORTANT?
======================
Normally, when a function finishes executing, its local variables are destroyed. But with closures:
- The inner function (sayHi) maintains a reference to the outer function's variables (message)
- The outer function's variables stay in memory as long as the inner function exists
- This allows data to persist and be protected from global scope

EXECUTION TIMELINE:
===================
1. greeting() is called
2. Inside greeting(): let message = 'Hi' is created
3. sayHi function is defined (but NOT called)
4. greeting() returns sayHi and finishes
5. Normally message would be destroyed, but it's not because:
6. hi now holds a reference to sayHi
7. sayHi needs message to work
8. JavaScript keeps message in memory
9. hi() is called
10. sayHi executes and logs 'Hi' to the console

KEY CONCEPTS:
=============
- Closure: A function that has access to variables from another function's scope
- Inner function: Function defined inside another function
- Scope: The context where variables are defined
- Lexical scoping: Inner functions can access outer function's variables

CONSOLE OUTPUT:
===============
Hi
