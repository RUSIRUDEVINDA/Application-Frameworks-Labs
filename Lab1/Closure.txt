Beginner-Level Explanation
This code demonstrates closures - one of JavaScript's most powerful (and initially confusing) features.
Breaking It Down:
1. The Outer Function
javascriptfunction greeting() {
    let message = 'Hi'
    // ... rest of code
}

greeting() is a regular function that creates a variable message with value 'Hi'.
2. The Inner Function
javascriptfunction sayHi() {
    console.log(message)  // Uses variable from parent function
}

sayHi() is a function inside greeting(). It can access message even though message belongs to the outer function.
3. Returning the Inner Function
javascriptreturn sayHi  // Notice: no parentheses!
Instead of calling sayHi(), we return the function itself (without calling it).

4. The Magic Happens Here
javascriptlet hi = greeting()  // hi now holds the sayHi function
hi()  // Outputs: "Hi"
Why This is Special (The Closure):
Normally, when a function finishes running, its variables disappear:
javascriptfunction normal() {
    let temp = "I'll disappear"
}
normal()
// temp is gone now!
But with closures, the inner function "remembers" the outer function's variables even after the outer function has finished:
javascriptlet hi = greeting()
// greeting() has finished running
// Normally, 'message' would be gone...
// But sayHi "closed over" it (captured it)

hi()  // Still prints "Hi"! 
```

### Real-World Analogy:

Think of it like a backpack:
- `greeting()` is like a workshop where you pack a backpack
- You put `message = 'Hi'` in the backpack
- `sayHi` is the person carrying that backpack
- Even after the workshop closes, the person still has the backpack with `message` inside!

### Output You'll See:
```
Hi
Common Use Cases:
1. Private Variables (data hiding):
javascriptfunction counter() {
    let count = 0  // Private!
    return function() {
        count++
        return count
    }
}
let increment = counter()
increment()  // 1
increment()  // 2
// You can't access 'count' directly from outside!
2. Event Handlers:
javascriptfunction setupButton(buttonId) {
    let clickCount = 0
    document.getElementById(buttonId).onclick = function() {
        clickCount++
        console.log(`Clicked ${clickCount} times`)
    }
}
The key idea: Inner functions keep outer variables "alive" even after the outer function finishes.